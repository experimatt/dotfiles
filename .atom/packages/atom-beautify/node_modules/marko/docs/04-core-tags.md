# Core tags and attributes

Marko provides a number of tags

## Control flow

### `<if>`, `<else-if>`, `<else>`

The `<if>`, `<else-if>`, and `<else>` tags provide conditional control-flow for templates.

```xml
<if(arriving)>
    <div>Hey there</div>
</if>
<else-if(leaving)>
    <div>Bye now</div>
</else-if>
<else>
    <div>What's up?</div>
</else>
```

Conditionals may also be applied as attributes:

```xml
<div if(arriving)>Hey there</div>
<div else-if(leaving)>Bye now</div>
<div else>What's up?</div>
```

And support complex expressions:

```xml
<if(Math.random() > 0.5)>
    <div>50-50 chance of seeing this</div>
</if>
```

### `<for>`

The `<for>` tag allows iterating over an array of items:
```xml
<ul>
    <for(color in colors)>
        <li>${color}</li>
    </for>
</ul>
```

It may also be applied as an attribute:
```xml
<ul>
    <li for(color in colors)>${color}</li>
</ul>
```

With either of the above templates, and the following value for `colors`:

```js
var colors = ['red', 'green', 'blue'];
```

The output HTML would be the following:

```html
<ul>
    <li>red</li>
    <li>green</li>
    <li>blue</li>
</ul>
```

#### Loop Status Variable
#### Loop Separator
#### Range Looping
#### Property Looping
#### Native JavaScript for-loop
#### Custom Iterator

### `<while>`

```xml
<table>
    <while(var row = getNextRow())>
        <tr><td>${row.content}</td></tr>
    </while>
</table>

<table>
    <for(row in rowsIterator())>
        <tr><td>${row.content}</td></tr>
    </for>
</table>
```

### `body-only-if`


## JavaScript

The following tags are always written using the [concise syntax](), even when using HTML syntax for tags that generate HTML output.

### `import`
> **Static:** The code generated by `import` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `import` tag is used to access data and functions from external files.  It follows the same syntax as the [JavaScript `import` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).

```xml
import sum from './utils/sum';
<div>The sum of 2 + 3 is ${sum(2, 3)}</div>
```

### `<export>`
> **Static:** The code generated by `export` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `export` tag is used to export values from the template.  It follows the same syntax as the [JavaScript `export` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export), but only named exports are supported (the default export is the template).

```xml
export var route = '/about';

<!doctype html>
<html>
    <body>
        <h1>About us</h1>
    </body>
</html>
```


### `static`
> **Static:** The code generated by `static` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `static` tag is used to write static javascript code that will be run once when the template is loaded.  It is the counterpart to [Inline JavaScript]() and follows the same syntax.  The `static` tag may be followed by a single javascript statement. A statement may continue onto subsequent lines if new lines are bounded by `{}`, `[]`, `()`, ``` `` ```, or `/**/`:

```xml
static var count = 0;
static var formatter = new Formatter();

static function sum(a, b) {
    return a + b;
};

<div>${formatter.format(sum(2, 3))}</div>
```

Multiple statements or an unbounded statement may be used by wrapping the statement(s) in a block:

```xml
static {
    var base = 2;
    function sum(a, b) {
        return base + a + b;
    };
}
```

## Reusable content

### `<include>`

The include tag is used to embed another template (or part of another template) in the current template.

The include tag can take a path to a template as the first argument:

```xml
<include('./path/to/template.marko')/>
```

The second argument may be used to pass input to the included template:

```xml
<include('./path/to/template.marko', { name:'Frank' })/>
```

Attributes may also be used to pass data to the included template and can be used in combination with the input parameter:

```xml
<include('./path/to/template.marko', data) name="Frank"/>
```

#### Layouts with nested attributes

In addition to including external content, you can inject additional content chunks into the external content.  This is accomplished by using nested attribute tags which are denoted by the `@` symbol:

_page.marko_
```xml
<include('./layout.marko')>
    <@body>
        <h1>Hello Marko</h1>
    </@body>
</include>
```

Then in your layout template you can include the injected content:

_layout.marko_
```xml
<!doctype html>
<html>
    <body>
        <!-- this comes from <@body> -->
        <include(input.body)/>
    </body>
</html>
```

<!--
- You can use many nested attribute tags for multiple injection points
- You can have repeated nested attribute tags by using `marko-tag.json` (components only)
- You can add additional attributes to an nested attribute tag
- You can pass data to a nested attribute tag's body?
-->

### `<include-html>`

### `<include-text>`

### `<macro>`



## Awaiting promises

### `<await>`


## Comments

### `<html-comment>`

## Compiler options

### `preserve-whitespace`
